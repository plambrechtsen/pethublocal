#!/usr/bin/env python3
"""
   Pet Hub MQTT to Parse MQTT messages from the Hub and create Home Assistant discovery topics and push to home assistant mqtt.

   Copyright (c) 2021, Peter Lambrechtsen (peter@crypt.nz)

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software Foundation,
   Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA
"""
import ast
import logging
import os
import pathlib
import socket
import sys
import json
import paho.mqtt.client as mqtt
from configparser import ConfigParser
from datetime import datetime
from box import Box
from pethubconst import *

sys.path.append('/code/source')
import pethubpacket as phlp
from pethubconst import *

# Debugging messages
LogLevel = logging.DEBUG  # File log level, either DEBUG or INFO
StateOnStartup = False  # Query all known devices state on startup

# Fixed values for MQTT Topic Names
# Topic for all messages generated by the hub, with the devices being a sub topic which is how the hub and devices work so can't be changed.
hub_topic = 'pethublocal/messages'
# Home Assistant MQTT Discovery Sensor topic for pets being added
ha_pet_topic = 'homeassistant/sensor/pethub/pet_'
# Home Assistant MQTT Discovery Sensor topic for devices being added
d_sen_t = 'homeassistant/sensor/pethub/device_'
# Home Assistant MQTT Discovery Switch topic for devices being added with on/off switch
d_swi_t = 'homeassistant/switch/pethub/device_'
# Home Assistant topics to subscribe to as we care about the state and set messages from HA.
hastatetopic = 'homeassistant/+/pethub/+/state'
hasettopic = 'homeassistant/+/pethub/+/set'

# Dict to hold all states
states = Box()

# Setup Logging framework to log to console without timestamps and log to file with timestamps
log = logging.getLogger('')
log.setLevel(LogLevel)
ch = logging.StreamHandler(sys.stdout)
log.addHandler(ch)
pathlib.Path("log").mkdir(exist_ok=True)
fh = logging.FileHandler('log/pethubmqtt-{:%Y-%m-%d}.log'.format(datetime.now()))
logformat = logging.Formatter('%(asctime)s - [%(levelname)-5.5s] - %(message)s')
fh.setFormatter(logformat)
log.addHandler(fh)

LogInitPrefix =     'Init    :' #Logging prefix for init messages
LogHubPrefix =      'Hub     :' #Logging prefix for Hub messages
LogDoorPrefix =     'Door    :' #Logging prefix for Door messages
LogFlapPrefix =     'Flap    :' #Logging prefix for Cat Flap messages
LogFeederPrefix =   'Feeder  :' #Logging prefix for Feeder messages
LogFelaquaPrefix =  'Felaqua :' #Logging prefix for Felaqua messages
LogMQTTMSGPrefix =  'MQTTMSG :' #Logging prefix for Felaqua messages
LogDatabasePrefix = 'Database:' #Logging prefix for Database messages
LogHAPrefix =       'HA      :' #Logging prefix for Home Assistant messages


# MQTT for pethublocal/hub and home assistant where the hub messages go, the broker sends the messages from the
# docker hub mqtt instance to your home assistant instance in the mosquitto.conf broker setting
hamqttip = ''
if os.environ.get('HAMQTTIP') is not None:
    hamqttip = os.environ.get('HAMQTTIP')
    log.info(LogInitPrefix + 'HAMQTTIP environment: ' + hamqttip)
else:
    parser = ConfigParser()
    if pathlib.Path("../config.ini").exists():
        with open("../config.ini") as stream:
            parser.read_string("[top]\n" + stream.read())
            if 'top' in parser and 'HAMQTTIP' in parser['top']:
                log.info(LogInitPrefix + 'HAMQTTIP from config.ini')
                hamqttip = parser['top']['HAMQTTIP']
    else:
        try:
            result = socket.gethostbyname_ex('mqtt')
        except:
            log.info(LogInitPrefix + "You're trying to run pethubmqtt.py locally but need to set the environment variable HAMQTTIP to point to your home assistant MQTT instance so exiting")
            exit(1)
        else:
            log.info(LogInitPrefix + "HAMQTTIP has not been set so connecting to internal mqtt instance")
            mqtthost = 'mqtt'  # Connect to internal mqtt instance if the home assistant one wasn't specified in the env
            mqttport = 1883

if ':' in hamqttip:
    hamqttipsplit = hamqttip.split(':')
    mqtthost = hamqttipsplit[0]
    mqttport = int(hamqttipsplit[1])
else:
    mqtthost = hamqttip
    mqttport = 1883
log.debug(LogInitPrefix + "HAMQTT Host: " + mqtthost)
log.debug(LogInitPrefix + "HAMQTT Port: " + str(mqttport))

# Feeder
def on_hub_message(client, obj, msg):
    msgsplit = msg.payload.decode("utf-8").split()
    if msgsplit[1] != "1000":
        log.debug(LogHubPrefix + "Hub    Raw: " + msg.topic + " " + str(msg.qos) + " " + msg.payload.decode("utf-8"))
        pethub = phlp.decodehubmqtt(msg.topic, msg.payload.decode("utf-8"))
        log.info(LogHubPrefix + "Hub Parsed: " + json.dumps(pethub))
        devid = "hub"
        for values in pethub['message'][-1:][0].values():
            if "State" in values:  # Hub State Change
                mv = next((fm for fm in pethub['message'] if fm['Operation'] == "State"), None)
                states.hub.State = mv['State']
                hasepub(devid + '/status', json.dumps(states.hub))
            if "Uptime" in values:  # Update Uptime
                mv = next((fm for fm in pethub['message'] if fm['Operation'] == "Uptime"), None)
                states.hub.Uptime = mv['Uptime'] + " Mins"
                hasepub(devid + '/status', json.dumps(states.hub))


# Pet Door
def on_petdoor_hub_message(client, obj, msg):
    msgsplit = msg.payload.decode("utf-8").split()
    if msgsplit[1] != "1000":
        # We get messages being reflected so ignore the command messages
        log.debug(LogDoorPrefix + "    Raw: " + msg.topic + " " + str(msg.qos) + " " + msg.payload.decode("utf-8"))
        pethub = phlp.decodehubmqtt(msg.topic, msg.payload.decode("utf-8"))
        mac_address = msg.topic.split("/")[-1]
        log.info(LogDoorPrefix + " Parsed: " + json.dumps(pethub))
        # Update battery state
        if "Battery" in pethub.message[0]:  # Update Battery State
            hasepub(mac_address + "_battery/state", pethub.message[0].Battery)
            log.debug(LogDoorPrefix + " Battery: " + pethub.message[0].Battery)
        #Check if the door has the wrong time and set it to the current time if it has skewed
        if 'TimeMins' in pethub.message[1].Operation:
            now = datetime.now()  # Current timestamp
            currentmins = (int(now.hour)*60)+int(now.minute)
            log.debug('Current Time in Mins: '+str(currentmins))
            log.debug('Door Time in Mins: '+str(mv['TimeMins']))
            if int(mv['TimeMins']) < (currentmins-2) or int(mv['TimeMins']) > (currentmins+2):
                settime = phlp.generatemessage(mac_address, 'SetTime', '')
                log.info('Set Time response: '+json.dumps(settime))

        # Update movements through the pet door
        if "PetMovement" in pethub.message[1].Operation:  # Pet Movement
            if pethub.message[0].Animal.lower() != "UnknownPet":
                happub(pethub.message[0].Animal.lower() + '/state', pethub.message[0].Direction)
            log.debug(LogDoorPrefix + " Movement: " + pethub.message[0].Animal.lower() + ' Direction ' + pethub.message[0].Direction)

        # Update lock state
        if 'LockState' in pethub.message[0]:  # Lock state
            if 'Curfew' in pethub.message[0].LockState:
                KeepIn = 'OFF'
                KeepOut = 'OFF'
                Curfew = 'ON'
            else:
                Curfew = 'OFF'
                if pethub.message[0].LockState in ['KeepIn', 'Locked']:
                    KeepIn = 'ON'
                else:
                    KeepIn = 'OFF'
                if pethub.message[0].LockState in ['KeepOut', 'Locked']:
                    KeepOut = 'ON'
                else:
                    KeepOut = 'OFF'
            haswpub(mac_address + '_KeepIn/state', KeepIn)
            haswpub(mac_address + '_KeepOut/state', KeepOut)
            haswpub(mac_address + '_Curfew/state', Curfew)

            # Update state value with change
            states[mac_address].State = pethub.message[0].LockState
            log.debug(LogDatabasePrefix + "Update LockStateNumber: " + str(pethub.message[0].LockStateNumber))
            lockmsg = phlp.updatedb('doors', mac_address, 'lockingmode', str(pethub.message[0].LockStateNumber))
            log.debug(LogDatabasePrefix + " updated " + str(lockmsg))

        # Update Curfew state
        if "CurfewState" in pethub.message[0]:  # Curfew state
            states[mac_address].Curfew.State = pethub.message[0].CurfewState
            states[mac_address].Curfew.Curfews = pethub.message[0].Curfews
            lockmsg = phlp.updatedb('doors', mac_address, 'curfewenabled', str(pethub.message[0].CurfewStateNumber))
            log.debug(LogDatabasePrefix + " updated " + str(lockmsg))

#        log.debug(LogDoorPrefix + " HA State - " + json.dumps(states[mac_address]))
        hasepub(mac_address + '/status', json.dumps(states[mac_address]))

# Home Assistant Lock State Update
def on_ha_lock_message(client, obj, msg):
    log.debug(LogHAPrefix + '    Raw: ' + msg.topic + ' ' + str(msg.qos) + ' ' + msg.payload.decode("utf-8"))
    devname = msg.topic.split("/")[3].split("_")
    log.debug(LogHAPrefix + 'LockMAC: ' + devname[1] + ' LockType ' + devname[2] + ' Action ' + str(msg.payload, "utf-8"))
    lockmsg = phlp.generatemessage(devname[1], devname[-1], str(msg.payload, "utf-8"))
    log.debug(LogHAPrefix + 'LockMAC Response ' + json.dumps(lockmsg))
    hubpub(lockmsg['topic'], lockmsg['msg'])

# Pet Door Curfew
def on_petdoor_ha_curfew_message(client, obj, msg):
    log.debug(LogDoorPrefix + '    Raw: ' + msg.topic + ' ' + str(msg.qos) + ' ' + msg.payload.decode("utf-8"))
    devname = msg.topic.split("/")[3].split("_")
    lockmsg = phlp.generatemessage(devname[1], 'CurfewLock', str(msg.payload, "utf-8"))
    log.debug(LogDoorPrefix + ' Curfew to Hub Message ' + json.dumps(lockmsg))
    hubpub(lockmsg['topic'], lockmsg['msg'])

# Feeder
def on_feeder_hub_message(client, obj, msg):
    msgsplit = msg.payload.decode("utf-8").split()
    if msgsplit[1] != "1000":
        log.debug(LogFeederPrefix + "    Raw: " + msg.topic + " " + str(msg.qos) + " " + msg.payload.decode("utf-8"))
        pethub = phlp.decodehubmqtt(msg.topic, msg.payload.decode("utf-8"))
        mac_address = msg.topic.split("/")[-1]
        log.debug(LogFeederPrefix + " Parsed: " + json.dumps(pethub))

        # Ack all the messages apart from the acks and the 132's
        for values in pethub['message']:
            # Don't ack an existing ack
            if values['Operation'] not in ['Ack', 'Data132Battery']:
                # Don't ack the last value in array as that is the message info
                if not isinstance(values['Operation'], list):
                    # Not an ack so we need to ack back.
                    log.info(LogFeederPrefix + " Ack Message " + values.data.msg)
                    ackmsg = phlp.generatemessage(mac_address, "Ack", values.data.msg+"-"+values.data.counter)
                    if ackmsg['topic'] and ackmsg['msg']:
                        hubpub(ackmsg['topic'], ackmsg['msg'])
                    else:
                        log.info(LogFeederPrefix + " Ack Failed " + json.dumps(ackmsg))

        for values in pethub['message'][-1:][0].values():
            if "Battery" in values:  # Update Battery State
                mv = next((fm for fm in pethub['message'] if fm['Operation'] == "Battery"), None)
                log.debug(LogFeederPrefix + " Battery State: " + mac_address + "_battery/state" + " " + mv['Battery'])
                hasepub(mac_address + "_battery/state", mv['Battery'])

            if "Feed" in values:
                mv = next((fm for fm in pethub['message'] if fm['Operation'] == "Feed"), None)
                log.debug(LogFeederPrefix + " Feed message - " + json.dumps(mv))
                states[mac_address].State = mv['Action']

                if mv['Action'] in ['Animal_Closed', 'Manual_Closed']:
                    # Update feeder current weight
                    states[mac_address]['Open Seconds'] = mv['Time']
                    states[mac_address]['Left weight'] = mv['LeftTo']
                    states[mac_address]['Right weight'] = mv['RightTo']

                    bowl = {"left": mv['LeftTo'], "right": mv['RightTo']}
                    log.debug(LogFeederPrefix + " Bowl State - " + json.dumps(bowl))

                    # Set Feeder Bowl Status only when the feeder is closing
                    hasepub(mac_address + '_bowl/state', json.dumps(bowl))

                    # Update the difference values the animal ate
                    if mv['Animal'] != "Manual":
                        petbowl = {"time": mv['Time'], "left": mv['LeftDelta'], "right": mv['RightDelta']}
                        log.debug(LogFeederPrefix + " Animal Ate " + json.dumps(petbowl))
                        happub(mv['Animal'].lower() + '_bowl/state', json.dumps(petbowl))

                else:
                    bowl = {"state": mv['Animal'] + " " + mv['Action'], "left": mv['LeftTo'], "right": mv['RightTo']}

                # Update Feeder Status
                log.debug(LogFeederPrefix + " State " + mac_address + " " + json.dumps(states[mac_address]))
                hasepub(mac_address + '/status', json.dumps(states[mac_address]))


# Cat Door
def on_catflap_hub_message(client, obj, msg):
    msgsplit = msg.payload.decode("utf-8").split()
    if msgsplit[1] != "1000":
        log.debug(LogFlapPrefix + '    Raw: ' + msg.topic + ' ' + str(msg.qos) + ' ' + msg.payload.decode("utf-8"))
        pethub = phlp.decodehubmqtt(msg.topic, msg.payload.decode("utf-8"))
        mac_address = msg.topic.split("/")[-1]
        log.debug(LogFlapPrefix + ' Parsed: ' + json.dumps(pethub))

        # Acknowledge all the messages apart from the acknowledgements themselves and the 132's messages generated by the hub.
        for values in pethub['message']:
            # Don't acknowledge an existing acknowledge message
            if values['Operation'] not in ['Ack', 'Data132Battery']:
                # Don't ack the last value in array as that is the message info
                if not isinstance(values['Operation'], list):
                    # Not an ack so we need to ack back.
                    log.info(LogFlapPrefix + " Ack Message " + values.data.msg)
                    ackmsg = phlp.generatemessage(mac_address, "Ack", values.data.msg+"-"+values.data.counter)
                    if ackmsg['topic'] and ackmsg['msg']:
                        hubpub(ackmsg['topic'], ackmsg['msg'])
                    else:
                        log.info(LogFlapPrefix + " Ack Failed " + json.dumps(ackmsg))

        if pethub['operation'] == 'Status':
            for values in pethub['message'][-1:][0].values():
                if "Battery" in values:  # Update Battery State
                    mv = next((fm for fm in pethub['message'] if fm['Operation'] == "Battery"), None)
                    hasepub(devid + "_battery/state", mv['Battery'])
                if "PetMovement" in values:  # Pet Movement
                    mv = next((fm for fm in pethub['message'] if fm['Operation'] == "PetMovement"), None)
                    happub(mv['Animal'].lower() + '/state', mv['Direction'])
                if "LockState" in values:  # Lock state
                    mv = next((fm for fm in pethub['message'] if fm['Operation'] == "LockState"), None)
                    if mv['LockState'] in ["KeepIn", "Locked"]:
                        KeepIn = "ON"
                    else:
                        KeepIn = "OFF"
                    if mv['LockState'] in ["KeepOut", "Locked"]:
                        KeepOut = "ON"
                    else:
                        KeepOut = "OFF"
                    haswpub(devid + "_KeepIn/state", KeepIn)
                    haswpub(devid + "_KeepOut/state", KeepOut)

                    # Update state value with change
                    states[mac_address].State = mv.LockState
                    hasepub(mac_address + '/status', json.dumps(states[mac_address]))

                    log.debug(LogDatabasePrefix + " Update LockStateNumber " + str(mv.LockStateNumber))
                    lockmsg = phlp.updatedb('doors', mac_address, 'lockingmode', str(mv.LockStateNumber))
                    log.debug(LogDatabasePrefix + " updated " + str(lockmsg))

                    # topicsplit = msg.topic.split("/")0
                    # log.debug("SQLITE: Update Lock State: " + str(topicsplit[-1]) + " State " + mv['Lock'])
                    # lockmsg = phlp.updatedb('doors',topicsplit[-1],'lockingmode', mv['Lock'])
                    # log.debug("SQLITE: Update Lock State result: " + lockmsg)

                    # Update state value with change
                    # states[mac_address].State=mv.LockState
                    # log.debug("Update DB LockStateNumber: "+str(mv.LockStateNumber))
                    # lockmsg = phlp.updatedb('doors',mac_address,'lockingmode', str(mv.LockStateNumber))
                    # log.debug("Database updated "+str(lockmsg))

                if "CurfewLockState" in values:  # Curfew Lock state
                    states[mac_address].Curfew.State = mv.LockState
                    # Set Device Status
                    log.debug(LogFlapPrefix + " Device Status - " + d_sen_t + devid + '/status' + " " + json.dumps(states[mac_address]))
                    hasepub(mac_address + '/status', json.dumps(states[mac_address]))

def on_catflap_curfew_message(client, obj, msg):
    log.info(LogFlapPrefix + " Curfew " + msg.topic + " " + msg.payload.decode("utf-8") + " " + json.dumps(pethub))
    log.info("** not implemented")

def on_ha_curfew_state(client, obj, msg):
    #Update all curfews for all doors to the time set, I should probably support individual door settings, patches welcome due to complexities in Home Assistant
    log.info("HA Curfew State Message " + msg.topic + " " + msg.payload.decode("utf-8"))
    lockmsg = phlp.updatedb('doors', '', 'curfews', str(msg.payload.decode("utf-8")))
    log.info("HA Curfew State Message result " + str(lockmsg))
#    setcurfewmsg = phlp.generatemessage(mac_address, "SetCurfewState", "UPD") #Update curfew on device
#    log.info("Update result " + json.dumps(setcurfewmsg))

# Umatched Message
def on_message(client, obj, msg):
    if "pethublocal/messages" in msg.topic:
        pethub = phlp.decodehubmqtt(msg.topic, msg.payload.decode("utf-8"))
        log.info(LogMQTTMSGPrefix + " Hub Message T=" + msg.topic + " QoS=" + str(msg.qos) + " Msg=" + str(msg.payload) + " Parsed=" + json.dumps(pethub))
    else:
        log.info(LogMQTTMSGPrefix + " HA message T=" + msg.topic + " QoS=" + str(msg.qos) + " Msg=" + str(msg.payload))

# Publish to homeassistant sensor topic
def hasepub(topic, message):
    ret = mc.publish(d_sen_t + topic, message, qos=0, retain=True)

# Publish to homeassistant switch topic
def haswpub(topic, message):
    ret = mc.publish(d_swi_t + topic, message, qos=0, retain=True)

# Publish to homeassistant pet topic
def happub(topic, message):
    ret = mc.publish(ha_pet_topic + topic, message, qos=0, retain=True)

# Publish to Hub with QOS=1 and don't retain messages
def hubpub(topic, message):
    ret = mc.publish(topic, message, qos=1, retain=False)

# Start Pet Hub Local
log.info("Starting Pet Hub Local")

# Connect to MQTT
mc = mqtt.Client('PetHub')
mc.on_message = on_message
if os.environ.get('HAMQTTUSERNAME') is not None and os.environ.get('HAMQTTPASSWORD') is not None:
    log.info(LogInitPrefix + "HAMQTTUSERNAME and HAMQTTPASSWORD set so setting MQTT broker password")
    username = os.environ.get('HAMQTTUSERNAME')
    password = os.environ.get('HAMQTTPASSWORD')
    log.debug("HAMQTTUSERNAME = {} and HAMQTTPASSWORD = {} ".format(username, password))
    mc.username_pw_set(username=username, password=password)
log.info(LogInitPrefix + "Connecting to Home Assistant MQTT endpoint at " + mqtthost + " port " + str(mqttport))
mc.connect(mqtthost, mqttport, 30)

# Gather init data from pethublocal.db
pethubinit = phlp.inithubmqtt()
log.debug(LogDatabasePrefix + 'SQLite init database response: ' + str(pethubinit))
log.info(LogDatabasePrefix + 'Load Devices from pethublocal.db and create Home Assistant MQTT discovery config topics')

for device in pethubinit.devices:
    log.debug(LogInitPrefix + 'Device:' + json.dumps(device))
    dev = device.name  # Shorter variable to save time and allow replacement if needed
    devid = device.mac_address  # Using Mac Address as device id in the topics we create for home assistant
    mac = device.mac_address  # Also set mac to mac address, this is used to indicate the MAC Address from the hub messages
    pid = device.product_id  # Product ID

    # Create Battery sensor as long as it isn't a hub as hubs don't have a battery
    if pid != 1:
        # Battery State Config
        configmessage = {'name': dev + ' Battery', 'icon': 'mdi:battery', 'unique_id': 'device_' + devid + '_battery', 'state_topic': d_sen_t + devid + '_battery/state'}
        log.debug(LogInitPrefix + 'Battery Config: ' + json.dumps(configmessage))
        hasepub(devid + '_battery/config', json.dumps(configmessage))
        # Set Battery Sensor state
        log.debug(LogInitPrefix + 'Battery State: ' + devid + '_battery/state' + ' ' + device.battery)
        hasepub(devid + '_battery/state', device.battery)

    if pid == 1:  # Hub
        log.info(LogInitPrefix + 'Loading Hub: ' + dev)
        log.debug(LogInitPrefix + 'Hub DB record: ' + str(device))

        # Dump current state, this generates the dumpstate message to the device to see what the devices current state is.
        if StateOnStartup:
            log.info(LogInitPrefix + 'Dump current state for ' + device.name)
            genmsg = phlp.generatemessage(mac, 'DumpState', '')
            hubpub(genmsg.topic, genmsg.msg)

        devid = 'hub'  # Only supporting one hub, perhaps I should support multiple.
        # Hub Uptime
        configmessage = {'name': dev, 'icon': 'mdi:radio-tower', 'unique_id': 'device_' + devid,
                         'stat_t': d_sen_t + devid + '/status', 'json_attr_t': d_sen_t + devid + '/status',
                         'val_tpl': '{{value_json["State"]}}'}
#                         'device':{'identifiers':devid,'name':'crypt','sw_version':'esphome v1.16.0 Mar  8 2021, 21:41:06','model':'WeMos D1 MINI ESP32','manufacturer':'pethublocal'}
        log.debug(LogInitPrefix + 'Hub Config: ' + json.dumps(configmessage))
        hasepub(devid + '/config', json.dumps(configmessage))

        # Hub status message
        states.hub = Box({'State': Online(device.state).name, 'Uptime': str(device.uptime) + ' Mins', 'Name': dev,
                          'Serial': device.serial_number, 'MAC Address': mac, 'LED Mode': HubLeds(device.led_mode).name,
                          'Pairing Mode': HubAdoption(device.pairing_mode).name})

        # Loop version json blob
        version = Box.from_json(device.version)
        for devs in version.device:
            states.hub[devs.title()] = version.device[devs]

        log.debug(LogInitPrefix + 'Hub Status: ' + json.dumps(states.hub))
        # Publish staus message
        hasepub(devid + '/status', json.dumps(states.hub))

        # Add callback for hub messages
        mc.message_callback_add(hub_topic, on_hub_message)

    if pid == 3 or pid == 6:  # Pet Door (3) or Cat Flap (6)

        states.update({mac: {'State': PetDoorLockState(device.lockingmode).name}})

        # Set time on device
        genmsg = phlp.generatemessage(mac, 'SetTime', '')  # Message 0c for Battery
        log.debug(LogInitPrefix + 'Generate settime Message: ' + json.dumps(genmsg))
        hubpub(genmsg.topic, genmsg.msg)

        mc.message_callback_add('homeassistant/datetime/pethub/curfew/set', on_ha_curfew_state)

        if pid == 3:  # Pet Door (3)
            log.info('Loading Pet Door: ' + device.name)
            log.debug('Pet Door Payload: ' + json.dumps(device))

            # Dump current state, this generates the dumpstate message to the device to see what the devices current state is.
            if StateOnStartup:
                log.info(LogInitPrefix + 'Dump current state for ' + device.name)
                genmsg = phlp.generatemessage(mac, 'DumpState', '')
                hubpub(genmsg.topic, genmsg.msg)

            # Adding callbacks to MQTT to call separate functions when messages arrive for pet dor
            mc.message_callback_add(hub_topic + '/' + mac, on_petdoor_hub_message)
            mc.message_callback_add(d_swi_t + devid + '_KeepIn/set', on_ha_lock_message)
            mc.message_callback_add(d_swi_t + devid + '_KeepOut/set', on_ha_lock_message)
            mc.message_callback_add(d_swi_t + devid + '_Curfew/set', on_petdoor_ha_curfew_message)

        if pid == 6:  # Cat Flap (6)
            log.info(LogInitPrefix + 'Loading Cat Flap: ' + device.name)
            log.debug(LogInitPrefix + 'Cat Flap Payload: ' + json.dumps(device))

            # Adding callbacks to MQTT to call separate functions when messages arrive for cat flap
            mc.message_callback_add(hub_topic + '/' + mac, on_catflap_hub_message)
            mc.message_callback_add(d_swi_t + devid + '_KeepIn/set', on_ha_lock_message)
            mc.message_callback_add(d_swi_t + devid + '_KeepOut/set', on_ha_lock_message)
            # mc.message_callback_add(d_swi_t+devid+"_Curfew/set", on_catflap_curfew_message)

            # Get Battery state
            genmsg = phlp.generatemessage(mac, 'Get', 'Battery')  # Message 0c for Battery
            log.debug(LogInitPrefix + 'Generate Cat Flap Message: ' + json.dumps(genmsg))
            hubpub(genmsg.topic, genmsg.msg)

        # Curfew
        if device.curfewenabled != 'None' and device.curfews != 'None':
            curfewstate = {'State': CurfewState(device.curfewenabled).name, 'Curfews': str(device.curfews)}
            states[mac].Curfew = curfewstate

            ##Curfew State Switch
            # configmessage={'name': dev+' Curfew', 'icon': 'mdi:door', 'unique_id': 'device_'+devid+'_curfew', 'command_topic': d_swi_t+devid+'_curfew/set', 'state_topic': d_swi_t+devid+'_curfew/status', 'json_attributes_topic': d_swi_t+devid+'_curfew/status', 'val_tpl': '{{value_json['State']}}' }
            # log.debug('Curfew Config: ' + json.dumps(configmessage))
            # haswpub(devid+'_curfew/config',json.dumps(configmessage))

            # Curfew State Times
            # curfewstate = {'State':CurfewOnOff(device.curfewenabled).name, 'Lock time':str(device.lock_time),'Unlock time':str(device.unlock_time)}
            # states[mac].curfew=curfewstate
            # log.debug('Curfew State: ' + json.dumps(states[mac].curfew))
            # haswpub(devid+'_curfew/status',json.dumps(states[mac].curfew))

        # Lock state as a switch
        if device.lockingmode != 'None':
            lockstate = ['KeepIn', 'KeepOut', 'Curfew']
            for key in lockstate:
                configmessage = {'name': dev + ' ' + key.replace('_', ' '), 'icon': 'mdi:door',
                                 'unique_id': 'device_' + devid + '_' + key,
                                 'command_topic': d_swi_t + devid + '_' + key + '/set',
                                 'state_topic': d_swi_t + devid + '_' + key + '/state'}
                log.debug('Add Lock switch: ' + devid + '_' + key + '/config' + ' ' + json.dumps(configmessage))
                haswpub(devid + '_' + key + '/config', json.dumps(configmessage))
            if device.lockingmode in [1, 3]:
                KeepIn = 'ON'
            else:
                KeepIn = 'OFF'
            if device.lockingmode in [2, 3]:
                KeepOut = 'ON'
            else:
                KeepOut = 'OFF'
            if device.lockingmode in [4]:
                curfew = 'ON'
            else:
                curfew = 'OFF'
            # Update HomeAssistant switch states
            haswpub(devid + '_KeepIn/state', KeepIn)
            haswpub(devid + '_KeepOut/state', KeepOut)
            haswpub(devid + '_Curfew/state', curfew)

        # State Config
        configmessage = {'name': dev, 'icon': 'mdi:door', 'unique_id': 'device_' + devid,
                         'stat_t': d_sen_t + devid + '/status', 'json_attr_t': d_sen_t + devid + '/status',
                         'val_tpl': '{{value_json["State"]}}'}
        log.debug(LogInitPrefix + "Flap: Device Config - " + d_sen_t + devid + '/status' + " " + json.dumps(configmessage))
        hasepub(devid + '/config', json.dumps(configmessage))

        # Set Device Status
        log.debug(LogInitPrefix + "Flap: Device Status - " + d_sen_t + devid + '/status' + " " + json.dumps(states[mac]))
        hasepub(devid + '/status', json.dumps(states[mac]))

    if pid == 4:  # Feeder
        log.info(LogInitPrefix + "Loading Feeder: " + device.name)
        log.debug(LogInitPrefix + "Feeder: Device Payload - " + str(device))
        # Add callback for feeder from hub
        mc.message_callback_add(hub_topic + '/' + mac, on_feeder_hub_message)

        # Init feeder
        # Get Battery state
        genmsg = phlp.generatemessage(mac, "Get", "Battery")  # Message 0c for Battery
        log.debug(LogInitPrefix + "Feeder: Generate Battery Message: " + json.dumps(genmsg))
        hubpub(genmsg.topic, genmsg.msg)

        # Set the time
        genmsg = phlp.generatemessage(mac, "SetTime", "")
        log.debug(LogInitPrefix + "Feeder: Generate settime Message: " + json.dumps(genmsg))
        hubpub(genmsg.topic, genmsg.msg)

        # Feeder Custom Mode
        feedercustommode = ",".join(FeederCustomMode(device.custommode).string_array())
        log.debug(LogInitPrefix + "Feeder: Custom Mode: " + str(feedercustommode))

        states.update({mac: {'State': 'Closed', 'Bowl Count': device.bowltype, 'Close Delay': FeederCloseDelay(device.close_delay).name,
                             'CustomMode': feedercustommode }})
        if device.bowltype == 2:  # Two bowls
            states[mac].update({"Left target": str(device.bowltarget1),
                                "Right target": str(device.bowltarget2)})  # Update local states Box object
            bowl = {"left": ["Current Left Weight", "g"],
                    "right": ["Current Right Weight", "g"]}  # Build config for HA MQTT discovery
            bowlstate = {"left": str(device.bowl1), "right": str(device.bowl2)}  # Set MQTT device State
        elif device.bowltype == 1:  # One bowl
            states[mac].update({"Target": str(device.bowltarget1)})  # Update local states Box object
            bowl = {"weight": ["Current Weight", "g"]}  # Build config for HA MQTT discovery
            bowlstate = {"weight": str(device.bowl1)}  # Set MQTT device State
        else:
            log.info(LogInitPrefix + "Unknown Bowl Configuration")

        # Feeder State Config
        configmessage = {"name": dev, "icon": "mdi:bowl", "unique_id": "device_" + devid,
                         "stat_t": d_sen_t + devid + "/status", "json_attr_t": d_sen_t + devid + "/status",
                         "val_tpl": "{{value_json['State']}}"}
        log.debug(LogInitPrefix + "Feeder: Config - " + d_sen_t + devid + '/status' + " " + json.dumps(states[mac]))
        hasepub(devid + '/config', json.dumps(configmessage))

        # Set Feeder Sensor Status
        log.debug(LogInitPrefix + "Feeder: Status - " + d_sen_t + devid + '/status' + " " + json.dumps(states[mac]))
        hasepub(devid + '/status', json.dumps(states[mac]))

        if device.bowltype in [1, 2]:
            # Create Bowl sensors
            for key, value in bowl.items():
                configmessage = {"name": dev + " " + value[0], "icon": "mdi:bowl",
                                 "unique_id": "device_" + devid + "_" + key,
                                 "state_topic": d_sen_t + devid + "_bowl/state", "unit_of_measurement": value[1],
                                 "value_template": "{{value_json." + key + "}}"}
                log.debug(LogInitPrefix + "Feeder: Bowl Config - " + d_sen_t + devid + '_bowl/state' + " " + json.dumps(bowlstate))
                hasepub(devid + '_' + key + '/config', json.dumps(configmessage))

            # Set Bowl Sensor State
            log.debug("Feeder: Bowl State - " + d_sen_t + devid + '_bowl/state' + " " + json.dumps(bowlstate))
            hasepub(devid + '_bowl/state', json.dumps(bowlstate))

    if pid == 8:  # Felaqua
        log.info(LogInitPrefix + "Loading Felaqua: " + device.name)
        log.debug(LogInitPrefix + "Felaqua Payload: " + str(device))
        # Add callback for felaqua from hub using same call as feeder
        mc.message_callback_add(hub_topic + '/' + mac, on_feeder_hub_message)

        # Get Battery state
        genmsg = phlp.generatemessage(mac, "get", "battery")  # Message 0c for Battery
        log.debug(LogInitPrefix + "Generate Battery Message: " + json.dumps(genmsg))
        hubpub(genmsg.topic, genmsg.msg)

        # Set the time
        genmsg = phlp.generatemessage(mac, "settime", "")  # Message 0c for Battery
        log.debug(LogInitPrefix + "Generate settime Message: " + json.dumps(genmsg))
        hubpub(genmsg.topic, genmsg.msg)

        # Configured water bowl
        states.update({mac: {'Weight': device.bowl1, 'Tare': device.bowltarget1}})

        # Feeder State Config
        configmessage = {"name": dev, "icon": "mdi:bowl", "unique_id": "device_" + devid,
                         "stat_t": d_sen_t + devid + "/status", "json_attr_t": d_sen_t + devid + "/status",
                         "val_tpl": "{{value_json['Weight']}}"}
        hasepub(devid + '/config', json.dumps(configmessage))

        # Set Feeder Sensor Status
        log.debug(LogInitPrefix + ' Feeder State ' + devid + '/status' + " " + json.dumps(states[mac]))
        hasepub(devid + '/status', json.dumps(states[mac]))

log.info(LogInitPrefix + "Load Pets from pethublocal.db and create Home Assistant MQTT discovery config topics")
for pet in pethubinit.pets:
    pn = pet.name
    pnid = pn.replace(' ', '_').lower()
    if pet.product_id == 3 or pet.product_id == 6:  # Pet Door or Cat Flap
        log.info(LogInitPrefix + " Loading Pet - " + pn + " for door " + pet.device)
        configmessage = {"name": pn, "icon": "mdi:" + Animal(int(pet.species)).name, "unique_id": "pet_" + pnid,
                         "state_topic": ha_pet_topic + pnid + "/state"}
        log.debug(LogInitPrefix + " Door config - " + json.dumps(configmessage))
        happub(pnid + '/config', json.dumps(configmessage))
        log.debug(LogInitPrefix + " Door state - " + AnimalState(int(pet.state)).name)
        happub(pnid + '/state', AnimalState(int(pet.state)).name)

    if pet.product_id == 4:  # Feeder
        log.info(LogInitPrefix + " Loading Pet - " + pn + " for feeder " + pet.device)
        feederarray = ast.literal_eval(pet.state)
        if len(feederarray) == 2:
            # Build config for HA MQTT discovery
            bowl = {"time": [" last feed time", "s"], "left": [" left weight", "g"], "right": [" right weight", "g"]}
            # Get current bowl state
            bowlstate = {"time": "0", "left": str(feederarray[0]), "right": str(feederarray[1])}
        elif len(feederarray) == 1:
            # Build config for HA MQTT discovery
            bowl = {"time": [" last feed time", "s"], "bowl": [" weight", "g"]}
            # Get current bowl state
            bowlstate = {"time": "0", "bowl": str(feederarray[0])}
        else:
            log.info("Unknown Bowl Configuration")

        for key, value in bowl.items():
            configmessage = {"name": pn + value[0], "icon": "mdi:" + Animal(pet.species).name,
                             "unique_id": "pet_" + pnid + "_" + key, "state_topic": ha_pet_topic + pnid + "_bowl/state",
                             "unit_of_measurement": value[1], "value_template": "{{value_json." + key + "}}"}
            log.debug(LogInitPrefix + " Feeder bowlconfig - " + json.dumps(configmessage))
            happub(pnid + '_' + key + '/config', json.dumps(configmessage))

        log.debug(LogInitPrefix + " Feeder bowlstate - " + json.dumps(bowlstate))
        happub(pnid + '_bowl/state', json.dumps(bowlstate))

# Everything done so ready to subscribe to the topics we care about.
log.info(LogInitPrefix + "Subscribe to pethublocal and home assistant topics")
mc.subscribe([("pethublocal/#", 1), (hastatetopic, 0), (hasettopic, 0)])
mc.loop_forever()
